import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  require_warning
} from "./chunk-NMKLRJ3K.js";
import {
  require_browser
} from "./chunk-4XA3XPRR.js";
import {
  require_react_dom
} from "./chunk-MMWG7BBY.js";
import {
  require_react
} from "./chunk-6D2327Y2.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-MXXBJFJ4.js";

// node_modules/react-input-mask/lib/react-input-mask.production.min.js
var require_react_input_mask_production_min = __commonJS({
  "node_modules/react-input-mask/lib/react-input-mask.production.min.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _interopDefault(e) {
      return e && "object" == typeof e && "default" in e ? e["default"] : e;
    }
    var React = _interopDefault(require_react());
    var reactDom = require_react_dom();
    function _defaults2(e, t) {
      for (var n = Object.getOwnPropertyNames(t), a = 0; a < n.length; a++) {
        var i = n[a], r = Object.getOwnPropertyDescriptor(t, i);
        r && r.configurable && e[i] === void 0 && Object.defineProperty(e, i, r);
      }
      return e;
    }
    function _extends() {
      return (_extends = Object.assign || function(e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var a in n)
            Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
        }
        return e;
      }).apply(this, arguments);
    }
    function _inheritsLoose(e, t) {
      e.prototype = Object.create(t.prototype), _defaults2(e.prototype.constructor = e, t);
    }
    function _objectWithoutPropertiesLoose(e, t) {
      if (null == e)
        return {};
      var n, a, i = {}, r = Object.keys(e);
      for (a = 0; a < r.length; a++)
        n = r[a], 0 <= t.indexOf(n) || (i[n] = e[n]);
      return i;
    }
    function _assertThisInitialized(e) {
      if (void 0 === e)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    var invariant = function(e, t, n, a, i, r, o, s) {
      if (!e) {
        var l;
        if (t === void 0)
          l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        else {
          var u = [n, a, i, r, o, s], c = 0;
          (l = new Error(t.replace(/%s/g, function() {
            return u[c++];
          }))).name = "Invariant Violation";
        }
        throw l.framesToPop = 1, l;
      }
    };
    var invariant_1 = invariant;
    function setInputSelection(e, t, n) {
      if ("selectionStart" in e && "selectionEnd" in e)
        e.selectionStart = t, e.selectionEnd = n;
      else {
        var a = e.createTextRange();
        a.collapse(true), a.moveStart("character", t), a.moveEnd("character", n - t), a.select();
      }
    }
    function getInputSelection(e) {
      var t = 0, n = 0;
      if ("selectionStart" in e && "selectionEnd" in e)
        t = e.selectionStart, n = e.selectionEnd;
      else {
        var a = document.selection.createRange();
        a.parentElement() === e && (t = -a.moveStart("character", -e.value.length), n = -a.moveEnd("character", -e.value.length));
      }
      return { start: t, end: n, length: n - t };
    }
    var defaultFormatChars = { 9: "[0-9]", a: "[A-Za-z]", "*": "[A-Za-z0-9]" };
    var defaultMaskChar = "_";
    function parseMask(e, t, n) {
      var a = "", i = "", r = null, o = [];
      if (t === void 0 && (t = defaultMaskChar), null == n && (n = defaultFormatChars), !e || "string" != typeof e)
        return { maskChar: t, formatChars: n, mask: null, prefix: null, lastEditablePosition: null, permanents: [] };
      var s = false;
      return e.split("").forEach(function(e2) {
        s = !s && "\\" === e2 || (s || !n[e2] ? (o.push(a.length), a.length === o.length - 1 && (i += e2)) : r = a.length + 1, a += e2, false);
      }), { maskChar: t, formatChars: n, prefix: i, mask: a, lastEditablePosition: r, permanents: o };
    }
    function isPermanentCharacter(e, t) {
      return -1 !== e.permanents.indexOf(t);
    }
    function isAllowedCharacter(e, t, n) {
      var a = e.mask, i = e.formatChars;
      if (!n)
        return false;
      if (isPermanentCharacter(e, t))
        return a[t] === n;
      var r = i[a[t]];
      return new RegExp(r).test(n);
    }
    function isEmpty(n, e) {
      return e.split("").every(function(e2, t) {
        return isPermanentCharacter(n, t) || !isAllowedCharacter(n, t, e2);
      });
    }
    function getFilledLength(e, t) {
      var n = e.maskChar, a = e.prefix;
      if (!n) {
        for (; t.length > a.length && isPermanentCharacter(e, t.length - 1); )
          t = t.slice(0, t.length - 1);
        return t.length;
      }
      for (var i = a.length, r = t.length; r >= a.length; r--) {
        var o = t[r];
        if (!isPermanentCharacter(e, r) && isAllowedCharacter(e, r, o)) {
          i = r + 1;
          break;
        }
      }
      return i;
    }
    function isFilled(e, t) {
      return getFilledLength(e, t) === e.mask.length;
    }
    function formatValue(e, t) {
      var n = e.maskChar, a = e.mask, i = e.prefix;
      if (!n) {
        for ((t = insertString(e, "", t, 0)).length < i.length && (t = i); t.length < a.length && isPermanentCharacter(e, t.length); )
          t += a[t.length];
        return t;
      }
      if (t)
        return insertString(e, formatValue(e, ""), t, 0);
      for (var r = 0; r < a.length; r++)
        isPermanentCharacter(e, r) ? t += a[r] : t += n;
      return t;
    }
    function clearRange(n, e, a, t) {
      var i = a + t, r = n.maskChar, o = n.mask, s = n.prefix, l = e.split("");
      if (r)
        return l.map(function(e2, t2) {
          return t2 < a || i <= t2 ? e2 : isPermanentCharacter(n, t2) ? o[t2] : r;
        }).join("");
      for (var u = i; u < l.length; u++)
        isPermanentCharacter(n, u) && (l[u] = "");
      return a = Math.max(s.length, a), l.splice(a, i - a), e = l.join(""), formatValue(n, e);
    }
    function insertString(r, o, e, s) {
      var l = r.mask, u = r.maskChar, c = r.prefix, t = e.split(""), h = isFilled(r, o);
      return !u && s > o.length && (o += l.slice(o.length, s)), t.every(function(e2) {
        for (; i = e2, isPermanentCharacter(r, a = s) && i !== l[a]; ) {
          if (s >= o.length && (o += l[s]), t2 = e2, n = s, u && isPermanentCharacter(r, n) && t2 === u)
            return true;
          if (++s >= l.length)
            return false;
        }
        var t2, n, a, i;
        return !isAllowedCharacter(r, s, e2) && e2 !== u || (s < o.length ? o = u || h || s < c.length ? o.slice(0, s) + e2 + o.slice(s + 1) : (o = o.slice(0, s) + e2 + o.slice(s), formatValue(r, o)) : u || (o += e2), ++s < l.length);
      }), o;
    }
    function getInsertStringLength(a, e, t, i) {
      var r = a.mask, o = a.maskChar, n = t.split(""), s = i;
      return n.every(function(e2) {
        for (; n2 = e2, isPermanentCharacter(a, t2 = i) && n2 !== r[t2]; )
          if (++i >= r.length)
            return false;
        var t2, n2;
        return (isAllowedCharacter(a, i, e2) || e2 === o) && i++, i < r.length;
      }), i - s;
    }
    function getLeftEditablePosition(e, t) {
      for (var n = t; 0 <= n; --n)
        if (!isPermanentCharacter(e, n))
          return n;
      return null;
    }
    function getRightEditablePosition(e, t) {
      for (var n = e.mask, a = t; a < n.length; ++a)
        if (!isPermanentCharacter(e, a))
          return a;
      return null;
    }
    function getStringValue(e) {
      return e || 0 === e ? e + "" : "";
    }
    function processChange(e, t, n, a, i) {
      var r = e.mask, o = e.prefix, s = e.lastEditablePosition, l = t, u = "", c = 0, h = 0, f = Math.min(i.start, n.start);
      if (n.end > i.start ? h = (c = getInsertStringLength(e, a, u = l.slice(i.start, n.end), f)) ? i.length : 0 : l.length < a.length && (h = a.length - l.length), l = a, h) {
        if (1 === h && !i.length)
          f = i.start === n.start ? getRightEditablePosition(e, n.start) : getLeftEditablePosition(e, n.start);
        l = clearRange(e, l, f, h);
      }
      return l = insertString(e, l, u, f), (f += c) >= r.length ? f = r.length : f < o.length && !c ? f = o.length : f >= o.length && f < s && c && (f = getRightEditablePosition(e, f)), u || (u = null), { value: l = formatValue(e, l), enteredString: u, selection: { start: f, end: f } };
    }
    function isWindowsPhoneBrowser() {
      var e = new RegExp("windows", "i"), t = new RegExp("phone", "i"), n = navigator.userAgent;
      return e.test(n) && t.test(n);
    }
    function isFunction(e) {
      return "function" == typeof e;
    }
    function getRequestAnimationFrame() {
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
    }
    function getCancelAnimationFrame() {
      return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame;
    }
    function defer(e) {
      return (!!getCancelAnimationFrame() ? getRequestAnimationFrame() : function() {
        return setTimeout(e, 1e3 / 60);
      })(e);
    }
    function cancelDefer(e) {
      (getCancelAnimationFrame() || clearTimeout)(e);
    }
    var InputElement = function(c) {
      function e(e2) {
        var f = c.call(this, e2) || this;
        f.focused = false, f.mounted = false, f.previousSelection = null, f.selectionDeferId = null, f.saveSelectionLoopDeferId = null, f.saveSelectionLoop = function() {
          f.previousSelection = f.getSelection(), f.saveSelectionLoopDeferId = defer(f.saveSelectionLoop);
        }, f.runSaveSelectionLoop = function() {
          null === f.saveSelectionLoopDeferId && f.saveSelectionLoop();
        }, f.stopSaveSelectionLoop = function() {
          null !== f.saveSelectionLoopDeferId && (cancelDefer(f.saveSelectionLoopDeferId), f.saveSelectionLoopDeferId = null, f.previousSelection = null);
        }, f.getInputDOMNode = function() {
          if (!f.mounted)
            return null;
          var e3 = reactDom.findDOMNode(_assertThisInitialized(_assertThisInitialized(f))), t3 = "undefined" != typeof window && e3 instanceof window.Element;
          if (e3 && !t3)
            return null;
          if ("INPUT" !== e3.nodeName && (e3 = e3.querySelector("input")), !e3)
            throw new Error("react-input-mask: inputComponent doesn't contain input node");
          return e3;
        }, f.getInputValue = function() {
          var e3 = f.getInputDOMNode();
          return e3 ? e3.value : null;
        }, f.setInputValue = function(e3) {
          var t3 = f.getInputDOMNode();
          t3 && (f.value = e3, t3.value = e3);
        }, f.setCursorToEnd = function() {
          var e3 = getFilledLength(f.maskOptions, f.value), t3 = getRightEditablePosition(f.maskOptions, e3);
          null !== t3 && f.setCursorPosition(t3);
        }, f.setSelection = function(e3, t3, n2) {
          void 0 === n2 && (n2 = {});
          var a2 = f.getInputDOMNode(), i2 = f.isFocused();
          a2 && i2 && (n2.deferred || setInputSelection(a2, e3, t3), null !== f.selectionDeferId && cancelDefer(f.selectionDeferId), f.selectionDeferId = defer(function() {
            f.selectionDeferId = null, setInputSelection(a2, e3, t3);
          }), f.previousSelection = { start: e3, end: t3, length: Math.abs(t3 - e3) });
        }, f.getSelection = function() {
          return getInputSelection(f.getInputDOMNode());
        }, f.getCursorPosition = function() {
          return f.getSelection().start;
        }, f.setCursorPosition = function(e3) {
          f.setSelection(e3, e3);
        }, f.isFocused = function() {
          return f.focused;
        }, f.getBeforeMaskedValueChangeConfig = function() {
          var e3 = f.maskOptions, t3 = e3.mask, n2 = e3.maskChar, a2 = e3.permanents, i2 = e3.formatChars;
          return { mask: t3, maskChar: n2, permanents: a2, alwaysShowMask: !!f.props.alwaysShowMask, formatChars: i2 };
        }, f.isInputAutofilled = function(e3, t3, n2, a2) {
          var i2 = f.getInputDOMNode();
          try {
            if (i2.matches(":-webkit-autofill"))
              return true;
          } catch (r2) {
          }
          return !f.focused || a2.end < n2.length && t3.end === e3.length;
        }, f.onChange = function(e3) {
          var t3 = _assertThisInitialized(_assertThisInitialized(f)).beforePasteState, n2 = _assertThisInitialized(_assertThisInitialized(f)).previousSelection, a2 = f.props.beforeMaskedValueChange, i2 = f.getInputValue(), r2 = f.value, o2 = f.getSelection();
          f.isInputAutofilled(i2, o2, r2, n2) && (r2 = formatValue(f.maskOptions, ""), n2 = { start: 0, end: 0, length: 0 }), t3 && (n2 = t3.selection, r2 = t3.value, o2 = { start: n2.start + i2.length, end: n2.start + i2.length, length: 0 }, i2 = r2.slice(0, n2.start) + i2 + r2.slice(n2.end), f.beforePasteState = null);
          var s2 = processChange(f.maskOptions, i2, o2, r2, n2), l2 = s2.enteredString, u2 = s2.selection, c2 = s2.value;
          if (isFunction(a2)) {
            var h = a2({ value: c2, selection: u2 }, { value: r2, selection: n2 }, l2, f.getBeforeMaskedValueChangeConfig());
            c2 = h.value, u2 = h.selection;
          }
          f.setInputValue(c2), isFunction(f.props.onChange) && f.props.onChange(e3), f.isWindowsPhoneBrowser ? f.setSelection(u2.start, u2.end, { deferred: true }) : f.setSelection(u2.start, u2.end);
        }, f.onFocus = function(e3) {
          var t3 = f.props.beforeMaskedValueChange, n2 = f.maskOptions, a2 = n2.mask, i2 = n2.prefix;
          if (f.focused = true, f.mounted = true, a2) {
            if (f.value)
              getFilledLength(f.maskOptions, f.value) < f.maskOptions.mask.length && f.setCursorToEnd();
            else {
              var r2 = formatValue(f.maskOptions, i2), o2 = formatValue(f.maskOptions, r2), s2 = getFilledLength(f.maskOptions, o2), l2 = getRightEditablePosition(f.maskOptions, s2), u2 = { start: l2, end: l2 };
              if (isFunction(t3)) {
                var c2 = t3({ value: o2, selection: u2 }, { value: f.value, selection: null }, null, f.getBeforeMaskedValueChangeConfig());
                o2 = c2.value, u2 = c2.selection;
              }
              var h = o2 !== f.getInputValue();
              h && f.setInputValue(o2), h && isFunction(f.props.onChange) && f.props.onChange(e3), f.setSelection(u2.start, u2.end);
            }
            f.runSaveSelectionLoop();
          }
          isFunction(f.props.onFocus) && f.props.onFocus(e3);
        }, f.onBlur = function(e3) {
          var t3 = f.props.beforeMaskedValueChange, n2 = f.maskOptions.mask;
          if (f.stopSaveSelectionLoop(), f.focused = false, n2 && !f.props.alwaysShowMask && isEmpty(f.maskOptions, f.value)) {
            var a2 = "";
            if (isFunction(t3))
              a2 = t3({ value: a2, selection: null }, { value: f.value, selection: f.previousSelection }, null, f.getBeforeMaskedValueChangeConfig()).value;
            var i2 = a2 !== f.getInputValue();
            i2 && f.setInputValue(a2), i2 && isFunction(f.props.onChange) && f.props.onChange(e3);
          }
          isFunction(f.props.onBlur) && f.props.onBlur(e3);
        }, f.onMouseDown = function(e3) {
          if (!f.focused && document.addEventListener) {
            f.mouseDownX = e3.clientX, f.mouseDownY = e3.clientY, f.mouseDownTime = (/* @__PURE__ */ new Date()).getTime();
            var r2 = function r3(e4) {
              if (document.removeEventListener("mouseup", r3), f.focused) {
                var t3 = Math.abs(e4.clientX - f.mouseDownX), n2 = Math.abs(e4.clientY - f.mouseDownY), a2 = Math.max(t3, n2), i2 = (/* @__PURE__ */ new Date()).getTime() - f.mouseDownTime;
                (a2 <= 10 && i2 <= 200 || a2 <= 5 && i2 <= 300) && f.setCursorToEnd();
              }
            };
            document.addEventListener("mouseup", r2);
          }
          isFunction(f.props.onMouseDown) && f.props.onMouseDown(e3);
        }, f.onPaste = function(e3) {
          isFunction(f.props.onPaste) && f.props.onPaste(e3), e3.defaultPrevented || (f.beforePasteState = { value: f.getInputValue(), selection: f.getSelection() }, f.setInputValue(""));
        }, f.handleRef = function(e3) {
          null == f.props.children && isFunction(f.props.inputRef) && f.props.inputRef(e3);
        };
        var t2 = e2.mask, n = e2.maskChar, a = e2.formatChars, i = e2.alwaysShowMask, r = e2.beforeMaskedValueChange, o = e2.defaultValue, s = e2.value;
        f.maskOptions = parseMask(t2, n, a), null == o && (o = ""), null == s && (s = o);
        var l = getStringValue(s);
        if (f.maskOptions.mask && (i || l) && (l = formatValue(f.maskOptions, l), isFunction(r))) {
          var u = e2.value;
          null == e2.value && (u = o), l = r({ value: l, selection: null }, { value: u = getStringValue(u), selection: null }, null, f.getBeforeMaskedValueChangeConfig()).value;
        }
        return f.value = l, f;
      }
      _inheritsLoose(e, c);
      var t = e.prototype;
      return t.componentDidMount = function() {
        this.mounted = true, this.getInputDOMNode() && (this.isWindowsPhoneBrowser = isWindowsPhoneBrowser(), this.maskOptions.mask && this.getInputValue() !== this.value && this.setInputValue(this.value));
      }, t.componentDidUpdate = function() {
        var e2 = this.previousSelection, t2 = this.props, n = t2.beforeMaskedValueChange, a = t2.alwaysShowMask, i = t2.mask, r = t2.maskChar, o = t2.formatChars, s = this.maskOptions, l = a || this.isFocused(), u = null != this.props.value, c2 = u ? getStringValue(this.props.value) : this.value, h = e2 ? e2.start : null;
        if (this.maskOptions = parseMask(i, r, o), this.maskOptions.mask) {
          !s.mask && this.isFocused() && this.runSaveSelectionLoop();
          var f = this.maskOptions.mask && this.maskOptions.mask !== s.mask;
          if (s.mask || u || (c2 = this.getInputValue()), (f || this.maskOptions.mask && (c2 || l)) && (c2 = formatValue(this.maskOptions, c2)), f) {
            var p = getFilledLength(this.maskOptions, c2);
            (null === h || p < h) && (h = isFilled(this.maskOptions, c2) ? p : getRightEditablePosition(this.maskOptions, p));
          }
          !this.maskOptions.mask || !isEmpty(this.maskOptions, c2) || l || u && this.props.value || (c2 = "");
          var d = { start: h, end: h };
          if (isFunction(n)) {
            var m = n({ value: c2, selection: d }, { value: this.value, selection: this.previousSelection }, null, this.getBeforeMaskedValueChangeConfig());
            c2 = m.value, d = m.selection;
          }
          this.value = c2;
          var g = this.getInputValue() !== this.value;
          g ? (this.setInputValue(this.value), this.forceUpdate()) : f && this.forceUpdate();
          var v = false;
          null != d.start && null != d.end && (v = !e2 || e2.start !== d.start || e2.end !== d.end), (v || g) && this.setSelection(d.start, d.end);
        } else
          s.mask && (this.stopSaveSelectionLoop(), this.forceUpdate());
      }, t.componentWillUnmount = function() {
        this.mounted = false, null !== this.selectionDeferId && cancelDefer(this.selectionDeferId), this.stopSaveSelectionLoop();
      }, t.render = function() {
        var t2, e2 = this.props, n = (e2.mask, e2.alwaysShowMask, e2.maskChar, e2.formatChars, e2.inputRef, e2.beforeMaskedValueChange, e2.children), a = _objectWithoutPropertiesLoose(e2, ["mask", "alwaysShowMask", "maskChar", "formatChars", "inputRef", "beforeMaskedValueChange", "children"]);
        if (n) {
          isFunction(n) || invariant_1(false);
          var i = ["onChange", "onPaste", "onMouseDown", "onFocus", "onBlur", "value", "disabled", "readOnly"], r = _extends({}, a);
          i.forEach(function(e3) {
            return delete r[e3];
          }), t2 = n(r), i.filter(function(e3) {
            return null != t2.props[e3] && t2.props[e3] !== a[e3];
          }).length && invariant_1(false);
        } else
          t2 = React.createElement("input", _extends({ ref: this.handleRef }, a));
        var o = { onFocus: this.onFocus, onBlur: this.onBlur };
        return this.maskOptions.mask && (a.disabled || a.readOnly || (o.onChange = this.onChange, o.onPaste = this.onPaste, o.onMouseDown = this.onMouseDown), null != a.value && (o.value = this.value)), t2 = React.cloneElement(t2, o);
      }, e;
    }(React.Component);
    module.exports = InputElement;
  }
});

// node_modules/react-input-mask/lib/react-input-mask.development.js
var require_react_input_mask_development = __commonJS({
  "node_modules/react-input-mask/lib/react-input-mask.development.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var React = _interopDefault(require_react());
    var reactDom = require_react_dom();
    var invariant = _interopDefault(require_browser());
    var warning = _interopDefault(require_warning());
    function _defaults2(obj, defaults) {
      var keys = Object.getOwnPropertyNames(defaults);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = Object.getOwnPropertyDescriptor(defaults, key);
        if (value && value.configurable && obj[key] === void 0) {
          Object.defineProperty(obj, key, value);
        }
      }
      return obj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _defaults2(subClass, superClass);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function setInputSelection(input, start, end) {
      if ("selectionStart" in input && "selectionEnd" in input) {
        input.selectionStart = start;
        input.selectionEnd = end;
      } else {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart("character", start);
        range.moveEnd("character", end - start);
        range.select();
      }
    }
    function getInputSelection(input) {
      var start = 0;
      var end = 0;
      if ("selectionStart" in input && "selectionEnd" in input) {
        start = input.selectionStart;
        end = input.selectionEnd;
      } else {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          start = -range.moveStart("character", -input.value.length);
          end = -range.moveEnd("character", -input.value.length);
        }
      }
      return {
        start,
        end,
        length: end - start
      };
    }
    var defaultFormatChars = {
      "9": "[0-9]",
      "a": "[A-Za-z]",
      "*": "[A-Za-z0-9]"
    };
    var defaultMaskChar = "_";
    function parseMask(mask, maskChar, formatChars) {
      var parsedMaskString = "";
      var prefix = "";
      var lastEditablePosition = null;
      var permanents = [];
      if (maskChar === void 0) {
        maskChar = defaultMaskChar;
      }
      if (formatChars == null) {
        formatChars = defaultFormatChars;
      }
      if (!mask || typeof mask !== "string") {
        return {
          maskChar,
          formatChars,
          mask: null,
          prefix: null,
          lastEditablePosition: null,
          permanents: []
        };
      }
      var isPermanent = false;
      mask.split("").forEach(function(character) {
        if (!isPermanent && character === "\\") {
          isPermanent = true;
        } else {
          if (isPermanent || !formatChars[character]) {
            permanents.push(parsedMaskString.length);
            if (parsedMaskString.length === permanents.length - 1) {
              prefix += character;
            }
          } else {
            lastEditablePosition = parsedMaskString.length + 1;
          }
          parsedMaskString += character;
          isPermanent = false;
        }
      });
      return {
        maskChar,
        formatChars,
        prefix,
        mask: parsedMaskString,
        lastEditablePosition,
        permanents
      };
    }
    function isPermanentCharacter(maskOptions, pos) {
      return maskOptions.permanents.indexOf(pos) !== -1;
    }
    function isAllowedCharacter(maskOptions, pos, character) {
      var mask = maskOptions.mask, formatChars = maskOptions.formatChars;
      if (!character) {
        return false;
      }
      if (isPermanentCharacter(maskOptions, pos)) {
        return mask[pos] === character;
      }
      var ruleChar = mask[pos];
      var charRule = formatChars[ruleChar];
      return new RegExp(charRule).test(character);
    }
    function isEmpty(maskOptions, value) {
      return value.split("").every(function(character, i) {
        return isPermanentCharacter(maskOptions, i) || !isAllowedCharacter(maskOptions, i, character);
      });
    }
    function getFilledLength(maskOptions, value) {
      var maskChar = maskOptions.maskChar, prefix = maskOptions.prefix;
      if (!maskChar) {
        while (value.length > prefix.length && isPermanentCharacter(maskOptions, value.length - 1)) {
          value = value.slice(0, value.length - 1);
        }
        return value.length;
      }
      var filledLength = prefix.length;
      for (var i = value.length; i >= prefix.length; i--) {
        var character = value[i];
        var isEnteredCharacter = !isPermanentCharacter(maskOptions, i) && isAllowedCharacter(maskOptions, i, character);
        if (isEnteredCharacter) {
          filledLength = i + 1;
          break;
        }
      }
      return filledLength;
    }
    function isFilled(maskOptions, value) {
      return getFilledLength(maskOptions, value) === maskOptions.mask.length;
    }
    function formatValue(maskOptions, value) {
      var maskChar = maskOptions.maskChar, mask = maskOptions.mask, prefix = maskOptions.prefix;
      if (!maskChar) {
        value = insertString(maskOptions, "", value, 0);
        if (value.length < prefix.length) {
          value = prefix;
        }
        while (value.length < mask.length && isPermanentCharacter(maskOptions, value.length)) {
          value += mask[value.length];
        }
        return value;
      }
      if (value) {
        var emptyValue = formatValue(maskOptions, "");
        return insertString(maskOptions, emptyValue, value, 0);
      }
      for (var i = 0; i < mask.length; i++) {
        if (isPermanentCharacter(maskOptions, i)) {
          value += mask[i];
        } else {
          value += maskChar;
        }
      }
      return value;
    }
    function clearRange(maskOptions, value, start, len) {
      var end = start + len;
      var maskChar = maskOptions.maskChar, mask = maskOptions.mask, prefix = maskOptions.prefix;
      var arrayValue = value.split("");
      if (!maskChar) {
        for (var i = end; i < arrayValue.length; i++) {
          if (isPermanentCharacter(maskOptions, i)) {
            arrayValue[i] = "";
          }
        }
        start = Math.max(prefix.length, start);
        arrayValue.splice(start, end - start);
        value = arrayValue.join("");
        return formatValue(maskOptions, value);
      }
      return arrayValue.map(function(character, i2) {
        if (i2 < start || i2 >= end) {
          return character;
        }
        if (isPermanentCharacter(maskOptions, i2)) {
          return mask[i2];
        }
        return maskChar;
      }).join("");
    }
    function insertString(maskOptions, value, insertStr, insertPosition) {
      var mask = maskOptions.mask, maskChar = maskOptions.maskChar, prefix = maskOptions.prefix;
      var arrayInsertStr = insertStr.split("");
      var isInputFilled = isFilled(maskOptions, value);
      var isUsablePosition = function isUsablePosition2(pos, character) {
        return !isPermanentCharacter(maskOptions, pos) || character === mask[pos];
      };
      var isUsableCharacter = function isUsableCharacter2(character, pos) {
        return !maskChar || !isPermanentCharacter(maskOptions, pos) || character !== maskChar;
      };
      if (!maskChar && insertPosition > value.length) {
        value += mask.slice(value.length, insertPosition);
      }
      arrayInsertStr.every(function(insertCharacter) {
        while (!isUsablePosition(insertPosition, insertCharacter)) {
          if (insertPosition >= value.length) {
            value += mask[insertPosition];
          }
          if (!isUsableCharacter(insertCharacter, insertPosition)) {
            return true;
          }
          insertPosition++;
          if (insertPosition >= mask.length) {
            return false;
          }
        }
        var isAllowed = isAllowedCharacter(maskOptions, insertPosition, insertCharacter) || insertCharacter === maskChar;
        if (!isAllowed) {
          return true;
        }
        if (insertPosition < value.length) {
          if (maskChar || isInputFilled || insertPosition < prefix.length) {
            value = value.slice(0, insertPosition) + insertCharacter + value.slice(insertPosition + 1);
          } else {
            value = value.slice(0, insertPosition) + insertCharacter + value.slice(insertPosition);
            value = formatValue(maskOptions, value);
          }
        } else if (!maskChar) {
          value += insertCharacter;
        }
        insertPosition++;
        return insertPosition < mask.length;
      });
      return value;
    }
    function getInsertStringLength(maskOptions, value, insertStr, insertPosition) {
      var mask = maskOptions.mask, maskChar = maskOptions.maskChar;
      var arrayInsertStr = insertStr.split("");
      var initialInsertPosition = insertPosition;
      var isUsablePosition = function isUsablePosition2(pos, character) {
        return !isPermanentCharacter(maskOptions, pos) || character === mask[pos];
      };
      arrayInsertStr.every(function(insertCharacter) {
        while (!isUsablePosition(insertPosition, insertCharacter)) {
          insertPosition++;
          if (insertPosition >= mask.length) {
            return false;
          }
        }
        var isAllowed = isAllowedCharacter(maskOptions, insertPosition, insertCharacter) || insertCharacter === maskChar;
        if (isAllowed) {
          insertPosition++;
        }
        return insertPosition < mask.length;
      });
      return insertPosition - initialInsertPosition;
    }
    function getLeftEditablePosition(maskOptions, pos) {
      for (var i = pos; i >= 0; --i) {
        if (!isPermanentCharacter(maskOptions, i)) {
          return i;
        }
      }
      return null;
    }
    function getRightEditablePosition(maskOptions, pos) {
      var mask = maskOptions.mask;
      for (var i = pos; i < mask.length; ++i) {
        if (!isPermanentCharacter(maskOptions, i)) {
          return i;
        }
      }
      return null;
    }
    function getStringValue(value) {
      return !value && value !== 0 ? "" : value + "";
    }
    function processChange(maskOptions, value, selection, previousValue, previousSelection) {
      var mask = maskOptions.mask, prefix = maskOptions.prefix, lastEditablePosition = maskOptions.lastEditablePosition;
      var newValue = value;
      var enteredString = "";
      var formattedEnteredStringLength = 0;
      var removedLength = 0;
      var cursorPosition = Math.min(previousSelection.start, selection.start);
      if (selection.end > previousSelection.start) {
        enteredString = newValue.slice(previousSelection.start, selection.end);
        formattedEnteredStringLength = getInsertStringLength(maskOptions, previousValue, enteredString, cursorPosition);
        if (!formattedEnteredStringLength) {
          removedLength = 0;
        } else {
          removedLength = previousSelection.length;
        }
      } else if (newValue.length < previousValue.length) {
        removedLength = previousValue.length - newValue.length;
      }
      newValue = previousValue;
      if (removedLength) {
        if (removedLength === 1 && !previousSelection.length) {
          var deleteFromRight = previousSelection.start === selection.start;
          cursorPosition = deleteFromRight ? getRightEditablePosition(maskOptions, selection.start) : getLeftEditablePosition(maskOptions, selection.start);
        }
        newValue = clearRange(maskOptions, newValue, cursorPosition, removedLength);
      }
      newValue = insertString(maskOptions, newValue, enteredString, cursorPosition);
      cursorPosition = cursorPosition + formattedEnteredStringLength;
      if (cursorPosition >= mask.length) {
        cursorPosition = mask.length;
      } else if (cursorPosition < prefix.length && !formattedEnteredStringLength) {
        cursorPosition = prefix.length;
      } else if (cursorPosition >= prefix.length && cursorPosition < lastEditablePosition && formattedEnteredStringLength) {
        cursorPosition = getRightEditablePosition(maskOptions, cursorPosition);
      }
      newValue = formatValue(maskOptions, newValue);
      if (!enteredString) {
        enteredString = null;
      }
      return {
        value: newValue,
        enteredString,
        selection: {
          start: cursorPosition,
          end: cursorPosition
        }
      };
    }
    function isWindowsPhoneBrowser() {
      var windows = new RegExp("windows", "i");
      var phone = new RegExp("phone", "i");
      var ua = navigator.userAgent;
      return windows.test(ua) && phone.test(ua);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function getRequestAnimationFrame() {
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
    }
    function getCancelAnimationFrame() {
      return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame;
    }
    function defer(fn) {
      var hasCancelAnimationFrame = !!getCancelAnimationFrame();
      var deferFn;
      if (hasCancelAnimationFrame) {
        deferFn = getRequestAnimationFrame();
      } else {
        deferFn = function deferFn2() {
          return setTimeout(fn, 1e3 / 60);
        };
      }
      return deferFn(fn);
    }
    function cancelDefer(deferId) {
      var cancelFn = getCancelAnimationFrame() || clearTimeout;
      cancelFn(deferId);
    }
    var InputElement = function(_React$Component) {
      _inheritsLoose(InputElement2, _React$Component);
      function InputElement2(props) {
        var _this;
        _this = _React$Component.call(this, props) || this;
        _this.focused = false;
        _this.mounted = false;
        _this.previousSelection = null;
        _this.selectionDeferId = null;
        _this.saveSelectionLoopDeferId = null;
        _this.saveSelectionLoop = function() {
          _this.previousSelection = _this.getSelection();
          _this.saveSelectionLoopDeferId = defer(_this.saveSelectionLoop);
        };
        _this.runSaveSelectionLoop = function() {
          if (_this.saveSelectionLoopDeferId === null) {
            _this.saveSelectionLoop();
          }
        };
        _this.stopSaveSelectionLoop = function() {
          if (_this.saveSelectionLoopDeferId !== null) {
            cancelDefer(_this.saveSelectionLoopDeferId);
            _this.saveSelectionLoopDeferId = null;
            _this.previousSelection = null;
          }
        };
        _this.getInputDOMNode = function() {
          if (!_this.mounted) {
            return null;
          }
          var input = reactDom.findDOMNode(_assertThisInitialized(_assertThisInitialized(_this)));
          var isDOMNode = typeof window !== "undefined" && input instanceof window.Element;
          if (input && !isDOMNode) {
            return null;
          }
          if (input.nodeName !== "INPUT") {
            input = input.querySelector("input");
          }
          if (!input) {
            throw new Error("react-input-mask: inputComponent doesn't contain input node");
          }
          return input;
        };
        _this.getInputValue = function() {
          var input = _this.getInputDOMNode();
          if (!input) {
            return null;
          }
          return input.value;
        };
        _this.setInputValue = function(value) {
          var input = _this.getInputDOMNode();
          if (!input) {
            return;
          }
          _this.value = value;
          input.value = value;
        };
        _this.setCursorToEnd = function() {
          var filledLength = getFilledLength(_this.maskOptions, _this.value);
          var pos = getRightEditablePosition(_this.maskOptions, filledLength);
          if (pos !== null) {
            _this.setCursorPosition(pos);
          }
        };
        _this.setSelection = function(start, end, options) {
          if (options === void 0) {
            options = {};
          }
          var input = _this.getInputDOMNode();
          var isFocused = _this.isFocused();
          if (!input || !isFocused) {
            return;
          }
          var _options = options, deferred = _options.deferred;
          if (!deferred) {
            setInputSelection(input, start, end);
          }
          if (_this.selectionDeferId !== null) {
            cancelDefer(_this.selectionDeferId);
          }
          _this.selectionDeferId = defer(function() {
            _this.selectionDeferId = null;
            setInputSelection(input, start, end);
          });
          _this.previousSelection = {
            start,
            end,
            length: Math.abs(end - start)
          };
        };
        _this.getSelection = function() {
          var input = _this.getInputDOMNode();
          return getInputSelection(input);
        };
        _this.getCursorPosition = function() {
          return _this.getSelection().start;
        };
        _this.setCursorPosition = function(pos) {
          _this.setSelection(pos, pos);
        };
        _this.isFocused = function() {
          return _this.focused;
        };
        _this.getBeforeMaskedValueChangeConfig = function() {
          var _this$maskOptions = _this.maskOptions, mask = _this$maskOptions.mask, maskChar = _this$maskOptions.maskChar, permanents = _this$maskOptions.permanents, formatChars = _this$maskOptions.formatChars;
          var alwaysShowMask = _this.props.alwaysShowMask;
          return {
            mask,
            maskChar,
            permanents,
            alwaysShowMask: !!alwaysShowMask,
            formatChars
          };
        };
        _this.isInputAutofilled = function(value, selection, previousValue, previousSelection) {
          var input = _this.getInputDOMNode();
          try {
            if (input.matches(":-webkit-autofill")) {
              return true;
            }
          } catch (e) {
          }
          if (!_this.focused) {
            return true;
          }
          return previousSelection.end < previousValue.length && selection.end === value.length;
        };
        _this.onChange = function(event) {
          var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)), beforePasteState = _assertThisInitialize.beforePasteState;
          var _assertThisInitialize2 = _assertThisInitialized(_assertThisInitialized(_this)), previousSelection = _assertThisInitialize2.previousSelection;
          var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;
          var value = _this.getInputValue();
          var previousValue = _this.value;
          var selection = _this.getSelection();
          if (_this.isInputAutofilled(value, selection, previousValue, previousSelection)) {
            previousValue = formatValue(_this.maskOptions, "");
            previousSelection = {
              start: 0,
              end: 0,
              length: 0
            };
          }
          if (beforePasteState) {
            previousSelection = beforePasteState.selection;
            previousValue = beforePasteState.value;
            selection = {
              start: previousSelection.start + value.length,
              end: previousSelection.start + value.length,
              length: 0
            };
            value = previousValue.slice(0, previousSelection.start) + value + previousValue.slice(previousSelection.end);
            _this.beforePasteState = null;
          }
          var changedState = processChange(_this.maskOptions, value, selection, previousValue, previousSelection);
          var enteredString = changedState.enteredString;
          var newSelection = changedState.selection;
          var newValue = changedState.value;
          if (isFunction(beforeMaskedValueChange)) {
            var modifiedValue2 = beforeMaskedValueChange({
              value: newValue,
              selection: newSelection
            }, {
              value: previousValue,
              selection: previousSelection
            }, enteredString, _this.getBeforeMaskedValueChangeConfig());
            newValue = modifiedValue2.value;
            newSelection = modifiedValue2.selection;
          }
          _this.setInputValue(newValue);
          if (isFunction(_this.props.onChange)) {
            _this.props.onChange(event);
          }
          if (_this.isWindowsPhoneBrowser) {
            _this.setSelection(newSelection.start, newSelection.end, {
              deferred: true
            });
          } else {
            _this.setSelection(newSelection.start, newSelection.end);
          }
        };
        _this.onFocus = function(event) {
          var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;
          var _this$maskOptions2 = _this.maskOptions, mask = _this$maskOptions2.mask, prefix = _this$maskOptions2.prefix;
          _this.focused = true;
          _this.mounted = true;
          if (mask) {
            if (!_this.value) {
              var emptyValue = formatValue(_this.maskOptions, prefix);
              var newValue = formatValue(_this.maskOptions, emptyValue);
              var filledLength = getFilledLength(_this.maskOptions, newValue);
              var cursorPosition = getRightEditablePosition(_this.maskOptions, filledLength);
              var newSelection = {
                start: cursorPosition,
                end: cursorPosition
              };
              if (isFunction(beforeMaskedValueChange)) {
                var modifiedValue2 = beforeMaskedValueChange({
                  value: newValue,
                  selection: newSelection
                }, {
                  value: _this.value,
                  selection: null
                }, null, _this.getBeforeMaskedValueChangeConfig());
                newValue = modifiedValue2.value;
                newSelection = modifiedValue2.selection;
              }
              var isInputValueChanged = newValue !== _this.getInputValue();
              if (isInputValueChanged) {
                _this.setInputValue(newValue);
              }
              if (isInputValueChanged && isFunction(_this.props.onChange)) {
                _this.props.onChange(event);
              }
              _this.setSelection(newSelection.start, newSelection.end);
            } else if (getFilledLength(_this.maskOptions, _this.value) < _this.maskOptions.mask.length) {
              _this.setCursorToEnd();
            }
            _this.runSaveSelectionLoop();
          }
          if (isFunction(_this.props.onFocus)) {
            _this.props.onFocus(event);
          }
        };
        _this.onBlur = function(event) {
          var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;
          var mask = _this.maskOptions.mask;
          _this.stopSaveSelectionLoop();
          _this.focused = false;
          if (mask && !_this.props.alwaysShowMask && isEmpty(_this.maskOptions, _this.value)) {
            var newValue = "";
            if (isFunction(beforeMaskedValueChange)) {
              var modifiedValue2 = beforeMaskedValueChange({
                value: newValue,
                selection: null
              }, {
                value: _this.value,
                selection: _this.previousSelection
              }, null, _this.getBeforeMaskedValueChangeConfig());
              newValue = modifiedValue2.value;
            }
            var isInputValueChanged = newValue !== _this.getInputValue();
            if (isInputValueChanged) {
              _this.setInputValue(newValue);
            }
            if (isInputValueChanged && isFunction(_this.props.onChange)) {
              _this.props.onChange(event);
            }
          }
          if (isFunction(_this.props.onBlur)) {
            _this.props.onBlur(event);
          }
        };
        _this.onMouseDown = function(event) {
          if (!_this.focused && document.addEventListener) {
            _this.mouseDownX = event.clientX;
            _this.mouseDownY = event.clientY;
            _this.mouseDownTime = (/* @__PURE__ */ new Date()).getTime();
            var mouseUpHandler = function mouseUpHandler2(mouseUpEvent) {
              document.removeEventListener("mouseup", mouseUpHandler2);
              if (!_this.focused) {
                return;
              }
              var deltaX = Math.abs(mouseUpEvent.clientX - _this.mouseDownX);
              var deltaY = Math.abs(mouseUpEvent.clientY - _this.mouseDownY);
              var axisDelta = Math.max(deltaX, deltaY);
              var timeDelta = (/* @__PURE__ */ new Date()).getTime() - _this.mouseDownTime;
              if (axisDelta <= 10 && timeDelta <= 200 || axisDelta <= 5 && timeDelta <= 300) {
                _this.setCursorToEnd();
              }
            };
            document.addEventListener("mouseup", mouseUpHandler);
          }
          if (isFunction(_this.props.onMouseDown)) {
            _this.props.onMouseDown(event);
          }
        };
        _this.onPaste = function(event) {
          if (isFunction(_this.props.onPaste)) {
            _this.props.onPaste(event);
          }
          if (!event.defaultPrevented) {
            _this.beforePasteState = {
              value: _this.getInputValue(),
              selection: _this.getSelection()
            };
            _this.setInputValue("");
          }
        };
        _this.handleRef = function(ref) {
          if (_this.props.children == null && isFunction(_this.props.inputRef)) {
            _this.props.inputRef(ref);
          }
        };
        var _mask = props.mask, _maskChar = props.maskChar, _formatChars = props.formatChars, _alwaysShowMask = props.alwaysShowMask, _beforeMaskedValueChange = props.beforeMaskedValueChange;
        var defaultValue = props.defaultValue, _value = props.value;
        _this.maskOptions = parseMask(_mask, _maskChar, _formatChars);
        if (defaultValue == null) {
          defaultValue = "";
        }
        if (_value == null) {
          _value = defaultValue;
        }
        var _newValue = getStringValue(_value);
        if (_this.maskOptions.mask && (_alwaysShowMask || _newValue)) {
          _newValue = formatValue(_this.maskOptions, _newValue);
          if (isFunction(_beforeMaskedValueChange)) {
            var oldValue = props.value;
            if (props.value == null) {
              oldValue = defaultValue;
            }
            oldValue = getStringValue(oldValue);
            var modifiedValue = _beforeMaskedValueChange({
              value: _newValue,
              selection: null
            }, {
              value: oldValue,
              selection: null
            }, null, _this.getBeforeMaskedValueChangeConfig());
            _newValue = modifiedValue.value;
          }
        }
        _this.value = _newValue;
        return _this;
      }
      var _proto = InputElement2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        if (!this.getInputDOMNode()) {
          return;
        }
        this.isWindowsPhoneBrowser = isWindowsPhoneBrowser();
        if (this.maskOptions.mask && this.getInputValue() !== this.value) {
          this.setInputValue(this.value);
        }
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        var previousSelection = this.previousSelection;
        var _this$props = this.props, beforeMaskedValueChange = _this$props.beforeMaskedValueChange, alwaysShowMask = _this$props.alwaysShowMask, mask = _this$props.mask, maskChar = _this$props.maskChar, formatChars = _this$props.formatChars;
        var previousMaskOptions = this.maskOptions;
        var showEmpty = alwaysShowMask || this.isFocused();
        var hasValue = this.props.value != null;
        var newValue = hasValue ? getStringValue(this.props.value) : this.value;
        var cursorPosition = previousSelection ? previousSelection.start : null;
        this.maskOptions = parseMask(mask, maskChar, formatChars);
        if (!this.maskOptions.mask) {
          if (previousMaskOptions.mask) {
            this.stopSaveSelectionLoop();
            this.forceUpdate();
          }
          return;
        } else if (!previousMaskOptions.mask && this.isFocused()) {
          this.runSaveSelectionLoop();
        }
        var isMaskChanged = this.maskOptions.mask && this.maskOptions.mask !== previousMaskOptions.mask;
        if (!previousMaskOptions.mask && !hasValue) {
          newValue = this.getInputValue();
        }
        if (isMaskChanged || this.maskOptions.mask && (newValue || showEmpty)) {
          newValue = formatValue(this.maskOptions, newValue);
        }
        if (isMaskChanged) {
          var filledLength = getFilledLength(this.maskOptions, newValue);
          if (cursorPosition === null || filledLength < cursorPosition) {
            if (isFilled(this.maskOptions, newValue)) {
              cursorPosition = filledLength;
            } else {
              cursorPosition = getRightEditablePosition(this.maskOptions, filledLength);
            }
          }
        }
        if (this.maskOptions.mask && isEmpty(this.maskOptions, newValue) && !showEmpty && (!hasValue || !this.props.value)) {
          newValue = "";
        }
        var newSelection = {
          start: cursorPosition,
          end: cursorPosition
        };
        if (isFunction(beforeMaskedValueChange)) {
          var modifiedValue = beforeMaskedValueChange({
            value: newValue,
            selection: newSelection
          }, {
            value: this.value,
            selection: this.previousSelection
          }, null, this.getBeforeMaskedValueChangeConfig());
          newValue = modifiedValue.value;
          newSelection = modifiedValue.selection;
        }
        this.value = newValue;
        var isValueChanged = this.getInputValue() !== this.value;
        if (isValueChanged) {
          this.setInputValue(this.value);
          this.forceUpdate();
        } else if (isMaskChanged) {
          this.forceUpdate();
        }
        var isSelectionChanged = false;
        if (newSelection.start != null && newSelection.end != null) {
          isSelectionChanged = !previousSelection || previousSelection.start !== newSelection.start || previousSelection.end !== newSelection.end;
        }
        if (isSelectionChanged || isValueChanged) {
          this.setSelection(newSelection.start, newSelection.end);
        }
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
        if (this.selectionDeferId !== null) {
          cancelDefer(this.selectionDeferId);
        }
        this.stopSaveSelectionLoop();
      };
      _proto.render = function render() {
        var _this$props2 = this.props, mask = _this$props2.mask, alwaysShowMask = _this$props2.alwaysShowMask, maskChar = _this$props2.maskChar, formatChars = _this$props2.formatChars, inputRef = _this$props2.inputRef, beforeMaskedValueChange = _this$props2.beforeMaskedValueChange, children = _this$props2.children, restProps = _objectWithoutPropertiesLoose(_this$props2, ["mask", "alwaysShowMask", "maskChar", "formatChars", "inputRef", "beforeMaskedValueChange", "children"]);
        var inputElement;
        process.env.NODE_ENV !== "production" ? warning(
          // parse mask to test against actual mask prop as this.maskOptions
          // will be updated later in componentDidUpdate
          !restProps.maxLength || !parseMask(mask, maskChar, formatChars).mask,
          "react-input-mask: maxLength property shouldn't be passed to the masked input. It breaks masking and unnecessary because length is limited by the mask length."
        ) : void 0;
        if (children) {
          !isFunction(children) ? process.env.NODE_ENV !== "production" ? invariant(false, "react-input-mask: children must be a function") : invariant(false) : void 0;
          var controlledProps = ["onChange", "onPaste", "onMouseDown", "onFocus", "onBlur", "value", "disabled", "readOnly"];
          var childrenProps = _extends({}, restProps);
          controlledProps.forEach(function(propId) {
            return delete childrenProps[propId];
          });
          inputElement = children(childrenProps);
          var conflictProps = controlledProps.filter(function(propId) {
            return inputElement.props[propId] != null && inputElement.props[propId] !== restProps[propId];
          });
          !!conflictProps.length ? process.env.NODE_ENV !== "production" ? invariant(false, "react-input-mask: the following props should be passed to the react-input-mask's component and should not be altered in children's function: " + conflictProps.join(", ")) : invariant(false) : void 0;
          process.env.NODE_ENV !== "production" ? warning(!inputRef, "react-input-mask: inputRef is ignored when children is passed, attach ref to the children instead") : void 0;
        } else {
          inputElement = React.createElement("input", _extends({
            ref: this.handleRef
          }, restProps));
        }
        var changedProps = {
          onFocus: this.onFocus,
          onBlur: this.onBlur
        };
        if (this.maskOptions.mask) {
          if (!restProps.disabled && !restProps.readOnly) {
            changedProps.onChange = this.onChange;
            changedProps.onPaste = this.onPaste;
            changedProps.onMouseDown = this.onMouseDown;
          }
          if (restProps.value != null) {
            changedProps.value = this.value;
          }
        }
        inputElement = React.cloneElement(inputElement, changedProps);
        return inputElement;
      };
      return InputElement2;
    }(React.Component);
    module.exports = InputElement;
  }
});

// node_modules/react-input-mask/index.js
var require_react_input_mask = __commonJS({
  "node_modules/react-input-mask/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    if (process.env.NODE_ENV === "production") {
      module.exports = require_react_input_mask_production_min();
    } else {
      module.exports = require_react_input_mask_development();
    }
  }
});
export default require_react_input_mask();
//# sourceMappingURL=react-input-mask.js.map
